--[[
Router ID E9 59 55 CD 7A B0 12 DE 77 07 11 87 8F 14 7C 78 4F C1 3D 37
Pubkey B 74 1C B6 63 E6 C3 9B 0C 68 42 83 3F C6 44 53 04 0A 47 D4 FB C9 54 7F 8B CF E6 DC 79 F9 EB CB 02
Privkey x B0 5F 13 56 60 78 EC FE D7 A5 44 71 1E 9E B5 72 24 BA 38 35 B1 94 FB 1E 56 CF 7C A6 03 99 7C 5A
Pubkey X B7 8B 48 88 6B 86 EF 8C AE 05 26 CA 53 E7 2F 0E 21 D5 A8 4D A6 35 A1 B3 89 68 55 AF 88 FE 9C 28
Router ID E9 59 55 CD 7A B0 12 DE 77 07 11 87 8F 14 7C 78 4F C1 3D 37
Pubkey B 74 1C B6 63 E6 C3 9B 0C 68 42 83 3F C6 44 53 04 0A 47 D4 FB C9 54 7F 8B CF E6 DC 79 F9 EB CB 02
Privkey x C8 D2 03 3B 40 A4 9C 80 90 49 CF EB FE 51 B9 68 B5 E9 52 15 26 8C 81 F2 03 1D 12 EB E6 BB 81 46
Pubkey X F3 BB 16 A1 D6 9D B5 6E 19 82 16 5F E5 33 CA 6F 17 24 6B 74 20 44 70 E1 54 E0 99 CA F2 96 5F 7C
Handshake Reply 81 07 E6 62 D4 15 21 9F 16 13 9B 25 A8 BD 47 29 75 81 1B B7 1B D6 AE CE A5 7F 21 66 C7 DA E1 4A 34 A8 61 CE DF 1A D9 5D 79 AD 8E 87 86 DC C3 AB 27 89 93 17 5E AF 55 BB C3 C0 9E E5 3C 1A 2B EA
Secret Input 88 5C 54 3F AA C1 EF 61 DE 21 B9 D3 60 E1 71 55 1E 98 EE 5B CC 0F 19 4E 48 FD C7 8B 96 2D AE 1D C0 1B CB 57 C1 21 D8 E2 DA AE C3 30 D6 32 64 86 7E CB FC 73 B4 43 9D 12 B1 38 4D 6B 6F AE A1 33 E9 59 55 CD 7A B0 12 DE 77 07 11 87 8F 14 7C 78 4F C1 3D 37 74 1C B6 63 E6 C3 9B 0C 68 42 83 3F C6 44 53 04 0A 47 D4 FB C9 54 7F 8B CF E6 DC 79 F9 EB CB 02 B7 8B 48 88 6B 86 EF 8C AE 05 26 CA 53 E7 2F 0E 21 D5 A8 4D A6 35 A1 B3 89 68 55 AF 88 FE 9C 28 81 07 E6 62 D4 15 21 9F 16 13 9B 25 A8 BD 47 29 75 81 1B B7 1B D6 AE CE A5 7F 21 66 C7 DA E1 4A 6E 74 6F 72 2D 63 75 72 76 65 32 35 35 31 39 2D 73 68 61 32 35 36 2D 31
Verify B5 43 13 40 53 92 54 88 0A CF C6 F5 15 8C 36 38 06 69 4E 8D 52 23 B1 28 75 05 18 65 29 09 92 3E
Auth Input B5 43 13 40 53 92 54 88 0A CF C6 F5 15 8C 36 38 06 69 4E 8D 52 23 B1 28 75 05 18 65 29 09 92 3E E9 59 55 CD 7A B0 12 DE 77 07 11 87 8F 14 7C 78 4F C1 3D 37 74 1C B6 63 E6 C3 9B 0C 68 42 83 3F C6 44 53 04 0A 47 D4 FB C9 54 7F 8B CF E6 DC 79 F9 EB CB 02 81 07 E6 62 D4 15 21 9F 16 13 9B 25 A8 BD 47 29 75 81 1B B7 1B D6 AE CE A5 7F 21 66 C7 DA E1 4A B7 8B 48 88 6B 86 EF 8C AE 05 26 CA 53 E7 2F 0E 21 D5 A8 4D A6 35 A1 B3 89 68 55 AF 88 FE 9C 28 6E 74 6F 72 2D 63 75 72 76 65 32 35 35 31 39 2D 73 68 61 32 35 36 2D 31 53 65 72 76 65 72
Auth 34 A8 61 CE DF 1A D9 5D 79 AD 8E 87 86 DC C3 AB 27 89 93 17 5E AF 55 BB C3 C0 9E E5 3C 1A 2B EA A7 3B 00 00 00 00 00 00 00 00 00 3D 6D 94 B2 FD A7 3B 78 58 1D A2 04 56 00 00 78 58 1D A2 04 56 00 00 16 B6 EA EA FC 7F 00 00 48 00 00 00 00 00 00 00 80 B5 EA EA FC 7F 00 00 90 58 1D A2 04 56 00 00 70 9C 1E A2 04 56 00 00 BD 01 CA A0 04 56 00 00 5C 00 00 00 00 00 00 00 78 B5 EA EA FC 7F 00 00 00 00 00 00 00 00 00 00 00 3D 6D 94 B2 FD A7 3B 00 00 00 00 00 00 00 00 12 B6 EA EA FC 7F 00 00 70 58 1D A2 04 56 00 00 D0 09 DA A1 04 56 00 00
Router ID D8 A2 D0 08 0B 0C 73 E1 DC 0E C9 F3 3B 49 7F 64 E5 FB 3F 52
Pubkey B 8A 8B 50 44 DE 2C AE 2D DE B1 2D 4A DD 01 75 D9 22 5E 70 B7 DD A5 36 32 6A E6 BF AE 78 89 3E 2B
Privkey x 18 A4 29 5A C2 40 50 F4 B3 34 29 6B 31 56 E0 78 E4 0F AD F6 FD A7 14 B4 20 D2 AE 84 CA EB 97 74
Pubkey X D7 66 9F C3 75 4B 41 D4 20 3D 99 AB 91 17 ED 61 FC 7E DD 7D CF C5 6A E0 F4 3F 89 4B 9C 1F 77 0A
Handshake Reply E4 BA EA F1 BD 9A 3E 77 8E FA 9D B7 F6 39 FE 60 03 C6 BA 1E E6 3A A9 9C CF 32 B9 9E 43 A8 2F 6A CF F4 81 E7 82 4C 2C 36 EB F6 7C 04 ED 28 0B 18 4F 9A 1C BD CD 4A 87 F9 78 79 86 29 0B E5 C2 7A
Secret Input DE AC 73 09 5F C0 EE A1 D9 AA FE 75 76 4F 57 49 42 F1 90 26 97 15 0F D9 B2 BA 5A 4D 73 41 34 7A 7E F4 3A 96 28 01 50 9E 3B E0 18 D9 B9 5B 3D 55 3E 87 75 BB AD 46 4C A6 44 C5 F8 48 29 EB 96 4B E9 59 55 CD 7A B0 12 DE 77 07 11 87 8F 14 7C 78 4F C1 3D 37 74 1C B6 63 E6 C3 9B 0C 68 42 83 3F C6 44 53 04 0A 47 D4 FB C9 54 7F 8B CF E6 DC 79 F9 EB CB 02 F3 BB 16 A1 D6 9D B5 6E 19 82 16 5F E5 33 CA 6F 17 24 6B 74 20 44 70 E1 54 E0 99 CA F2 96 5F 7C E4 BA EA F1 BD 9A 3E 77 8E FA 9D B7 F6 39 FE 60 03 C6 BA 1E E6 3A A9 9C CF 32 B9 9E 43 A8 2F 6A 6E 74 6F 72 2D 63 75 72 76 65 32 35 35 31 39 2D 73 68 61 32 35 36 2D 31
Verify 1A 5D 2F B3 BD DF A2 CB 0B 38 37 F9 84 8B B2 B1 F4 2F 3C 2A 3B BE EA 2E 5C 27 2F FD 29 F4 F0 72
Auth Input 1A 5D 2F B3 BD DF A2 CB 0B 38 37 F9 84 8B B2 B1 F4 2F 3C 2A 3B BE EA 2E 5C 27 2F FD 29 F4 F0 72 E9 59 55 CD 7A B0 12 DE 77 07 11 87 8F 14 7C 78 4F C1 3D 37 74 1C B6 63 E6 C3 9B 0C 68 42 83 3F C6 44 53 04 0A 47 D4 FB C9 54 7F 8B CF E6 DC 79 F9 EB CB 02 E4 BA EA F1 BD 9A 3E 77 8E FA 9D B7 F6 39 FE 60 03 C6 BA 1E E6 3A A9 9C CF 32 B9 9E 43 A8 2F 6A F3 BB 16 A1 D6 9D B5 6E 19 82 16 5F E5 33 CA 6F 17 24 6B 74 20 44 70 E1 54 E0 99 CA F2 96 5F 7C 6E 74 6F 72 2D 63 75 72 76 65 32 35 35 31 39 2D 73 68 61 32 35 36 2D 31 53 65 72 76 65 72
Auth CF F4 81 E7 82 4C 2C 36 EB F6 7C 04 ED 28 0B 18 4F 9A 1C BD CD 4A 87 F9 78 79 86 29 0B E5 C2 7A A7 3B 00 00 00 00 00 00 00 00 00 3D 6D 94 B2 FD A7 3B 48 70 B3 A1 04 56 00 00 48 70 B3 A1 04 56 00 00 16 B6 EA EA FC 7F 00 00 48 00 00 00 00 00 00 00 80 B5 EA EA FC 7F 00 00 60 70 B3 A1 04 56 00 00 30 E1 1A A2 04 56 00 00 BD 01 CA A0 04 56 00 00 5C 00 00 00 00 00 00 00 78 B5 EA EA FC 7F 00 00 00 00 00 00 00 00 00 00 00 3D 6D 94 B2 FD A7 3B 00 00 00 00 00 00 00 00 12 B6 EA EA FC 7F 00 00 40 70 B3 A1 04 56 00 00 60 AA 1A A2 04 56 00 00
Handshake Reply A1 D8 F2 71 7D 93 2B 17 7F DB 49 76 71 8B C8 6B 51 FD FA F9 52 62 FE A3 4D 85 A7 B8 34 A4 19 3A A9 67 2A 4B 4F 5E 24 A7 24 71 C4 EF E1 2B A3 0B BB 91 2D EA 73 C6 D0 CA 9E 86 06 1A B1 3C AA 91
Secret Input 7E BD 7F D4 71 FD 3C D5 A6 93 74 45 F2 AC 33 7D FC 2C 49 49 4A D2 96 6D 77 6D FD 83 6C 4D 7E 45 E0 10 5C 8D B4 50 83 38 F1 62 1D E5 F5 FF 00 CD A6 9C CA D0 4F 72 F2 FB CC 60 99 03 A4 D2 DB 65 D8 A2 D0 08 0B 0C 73 E1 DC 0E C9 F3 3B 49 7F 64 E5 FB 3F 52 8A 8B 50 44 DE 2C AE 2D DE B1 2D 4A DD 01 75 D9 22 5E 70 B7 DD A5 36 32 6A E6 BF AE 78 89 3E 2B D7 66 9F C3 75 4B 41 D4 20 3D 99 AB 91 17 ED 61 FC 7E DD 7D CF C5 6A E0 F4 3F 89 4B 9C 1F 77 0A A1 D8 F2 71 7D 93 2B 17 7F DB 49 76 71 8B C8 6B 51 FD FA F9 52 62 FE A3 4D 85 A7 B8 34 A4 19 3A 6E 74 6F 72 2D 63 75 72 76 65 32 35 35 31 39 2D 73 68 61 32 35 36 2D 31
Verify 3B E0 E2 AE E2 29 00 C6 3D AC 8B 58 26 4E 2D 8C 85 5A E5 48 84 35 9C 06 0B 4D 25 F0 EF 3C F7 D9
Auth Input 3B E0 E2 AE E2 29 00 C6 3D AC 8B 58 26 4E 2D 8C 85 5A E5 48 84 35 9C 06 0B 4D 25 F0 EF 3C F7 D9 D8 A2 D0 08 0B 0C 73 E1 DC 0E C9 F3 3B 49 7F 64 E5 FB 3F 52 8A 8B 50 44 DE 2C AE 2D DE B1 2D 4A DD 01 75 D9 22 5E 70 B7 DD A5 36 32 6A E6 BF AE 78 89 3E 2B A1 D8 F2 71 7D 93 2B 17 7F DB 49 76 71 8B C8 6B 51 FD FA F9 52 62 FE A3 4D 85 A7 B8 34 A4 19 3A D7 66 9F C3 75 4B 41 D4 20 3D 99 AB 91 17 ED 61 FC 7E DD 7D CF C5 6A E0 F4 3F 89 4B 9C 1F 77 0A 6E 74 6F 72 2D 63 75 72 76 65 32 35 35 31 39 2D 73 68 61 32 35 36 2D 31 53 65 72 76 65 72
Auth A9 67 2A 4B 4F 5E 24 A7 24 71 C4 EF E1 2B A3 0B BB 91 2D EA 73 C6 D0 CA 9E 86 06 1A B1 3C AA 91 00 00 02 00 00 1C 08 72 A1 28 00 3D 6D 94 B2 FD A7 3B E8 5B 1D A2 04 56 00 00 E8 5B 1D A2 04 56 00 00 A6 B6 EA EA FC 7F 00 00 48 00 00 00 00 00 00 00 10 B6 EA EA FC 7F 00 00 00 5C 1D A2 04 56 00 00 A0 D2 1A A2 04 56 00 00 BD 01 CA A0 04 56 00 00 5C 00 00 00 00 00 00 00 08 B6 EA EA FC 7F 00 00 09 00 00 00 00 00 00 00 00 3D 6D 94 B2 FD A7 3B 31 00 00 00 04 56 00 00 A2 B6 EA EA FC 7F 00 00 E0 5B 1D A2 04 56 00 00 D0 09 DA A1 04 56 00 00
Router ID 53 02 77 86 64 66 A1 42 5F 43 A7 3D BF CB 5F C7 41 0C 98 52
Pubkey B 5E 89 5D 65 30 4A 3A 18 94 61 66 60 14 3F 7A F5 75 7F E0 8B C1 80 45 C7 85 5E E8 DE BB 9E 6C 47
Privkey x F0 FE CE 5D 6C 73 AD BA 08 5F 2A C9 99 A0 DE F0 57 B0 98 8D B3 05 FF E6 CB 0D C7 D7 20 AC DC 75
Pubkey X 9B C7 81 30 79 F1 57 E3 1B D2 D0 FE 1E 47 1F 4C 15 F2 27 8D 1A 26 04 B2 0B A9 C7 76 80 A9 C7 31
Handshake Reply 75 C9 A4 7B 6A C0 6C 9F E4 59 3E 55 98 60 09 EF 7D DF AF 91 0C 9B 25 E0 57 C2 DE 0E 41 31 11 06 13 1F D5 95 56 7B 34 47 BE 23 BD 3F ED 9F 33 7E 2F E6 CD 15 01 72 93 B2 42 D7 EE 26 AB 03 F6 2D
Secret Input F5 7B 1C 69 7F F8 D1 42 5D 2D 45 B2 13 37 9A 09 9F 37 68 95 39 BA 09 94 C1 A5 4D 00 E8 BB F0 0F 5A CC 2F 63 A9 1C 95 FD 03 7E 64 8D 00 19 4B 5F A9 AC 87 B0 FB 15 90 FD 67 C3 92 0B 3D 42 42 11 53 02 77 86 64 66 A1 42 5F 43 A7 3D BF CB 5F C7 41 0C 98 52 5E 89 5D 65 30 4A 3A 18 94 61 66 60 14 3F 7A F5 75 7F E0 8B C1 80 45 C7 85 5E E8 DE BB 9E 6C 47 9B C7 81 30 79 F1 57 E3 1B D2 D0 FE 1E 47 1F 4C 15 F2 27 8D 1A 26 04 B2 0B A9 C7 76 80 A9 C7 31 75 C9 A4 7B 6A C0 6C 9F E4 59 3E 55 98 60 09 EF 7D DF AF 91 0C 9B 25 E0 57 C2 DE 0E 41 31 11 06 6E 74 6F 72 2D 63 75 72 76 65 32 35 35 31 39 2D 73 68 61 32 35 36 2D 31
Verify B6 9A 2F DE 28 48 94 35 2B 8D CB B0 7A 1A C6 01 34 43 FE 40 EA 65 D0 7D 0B A6 27 39 6A 9A 23 DF
Auth Input B6 9A 2F DE 28 48 94 35 2B 8D CB B0 7A 1A C6 01 34 43 FE 40 EA 65 D0 7D 0B A6 27 39 6A 9A 23 DF 53 02 77 86 64 66 A1 42 5F 43 A7 3D BF CB 5F C7 41 0C 98 52 5E 89 5D 65 30 4A 3A 18 94 61 66 60 14 3F 7A F5 75 7F E0 8B C1 80 45 C7 85 5E E8 DE BB 9E 6C 47 75 C9 A4 7B 6A C0 6C 9F E4 59 3E 55 98 60 09 EF 7D DF AF 91 0C 9B 25 E0 57 C2 DE 0E 41 31 11 06 9B C7 81 30 79 F1 57 E3 1B D2 D0 FE 1E 47 1F 4C 15 F2 27 8D 1A 26 04 B2 0B A9 C7 76 80 A9 C7 31 6E 74 6F 72 2D 63 75 72 76 65 32 35 35 31 39 2D 73 68 61 32 35 36 2D 31 53 65 72 76 65 72
Auth 13 1F D5 95 56 7B 34 47 BE 23 BD 3F ED 9F 33 7E 2F E6 CD 15 01 72 93 B2 42 D7 EE 26 AB 03 F6 2D 00 00 D0 09 DA A1 04 56 00 00 00 3D 6D 94 B2 FD A7 3B 68 7C 1E A2 04 56 00 00 68 7C 1E A2 04 56 00 00 A6 B6 EA EA FC 7F 00 00 48 00 00 00 00 00 00 00 10 B6 EA EA FC 7F 00 00 80 7C 1E A2 04 56 00 00 90 A8 1A A2 04 56 00 00 BD 01 CA A0 04 56 00 00 5C 00 00 00 00 00 00 00 08 B6 EA EA FC 7F 00 00 00 00 00 00 00 00 00 00 00 3D 6D 94 B2 FD A7 3B 00 00 00 00 00 00 00 00 A2 B6 EA EA FC 7F 00 00 60 7C 1E A2 04 56 00 00 D0 09 DA A1 04 56 00 00
]] require "tor.dir"
local tor = {}
local PAYLOAD_LEN = 509
local PK_PAD_LEN = 42
local PK_ENC_LEN = 128
local HASH_LEN = 20
local ID_LENGTH = 20
local ssl = require "blue.ssl"
local struct = require "blue.struct"
local curve = require "blue.tor.curve"
local sha1 = require "blue.sha1"
local rsa = require "blue.tor.rsa"
local hmac = require "blue.tor.hmac"
local aes = require "blue.tor.aes"
local ed25519 = require "blue.tor.ed25519"
local util = require "blue.util"
local scheduler = require "blue.scheduler"
local create_path = require "blue.tor.path"
local matrix = require "blue.matrix.init"
local tor_cmds = {}
do
  local function add_cmd(id, name)
    local cmd = {id = id, name = name}
    tor_cmds[id] = cmd
    tor_cmds[name] = cmd
  end
  add_cmd(0, "padding")
  add_cmd(1, "create")
  add_cmd(2, "created")
  add_cmd(3, "relay")
  add_cmd(4, "destroy")
  add_cmd(5, "create_fast")
  add_cmd(6, "created_fast")
  add_cmd(8, "netinfo")
  add_cmd(9, "relay_early")
  add_cmd(10, "create2")
  add_cmd(11, "created2")
  add_cmd(12, "padding_negotiate")
  add_cmd(7, "versions")
  add_cmd(128, "vpadding")
  add_cmd(129, "certs")
  add_cmd(130, "auth_challenge")
  add_cmd(131, "authenticate")
  add_cmd(132, "authorize")
end
function tor.create(args)
  assert(args.first_relay)
  assert(args.first_relay.ip)
  assert(args.first_relay.port)
  local socket_provider = ssl.create()
  print("CONN TO", args.first_relay.ip, args.first_relay.port)
  local conn = socket_provider.connect(args.first_relay.ip, args.first_relay.port)

  local socket_mutex = util.mutex()
  local recv_buf = ""
  local circ_id_len = "H"

  local circuits = {}
  local function register_circuit(id)
    local circuit = {}
    local buffer = {}
    local cb
    circuits[id] = function(cmd, data)
      local rcb = cb
      cb = nil
      table.insert(buffer, {cmd = cmd, data = data})
      if rcb then
        scheduler.addthread(function()
          scheduler.sleep(0)
          rcb()
        end)
      end
    end
    function circuit:read_cell()
      while #buffer == 0 do
        assert(not cb, "Attempt to multithread on single circuit")
        cb = scheduler.getresume()
        scheduler.yield()
      end
      local item = table.remove(buffer, 1)
      return tor_cmds[item.cmd].name, item.data
    end
    function circuit:send_raw_cell(cmd, data)
      socket_mutex:lock()
      -- print("Send Cell", tor_cmds[cmd].name)
      local sd = struct.pack(">" .. circ_id_len .. "B", id, cmd) .. data
      assert(conn:send(sd))
      socket_mutex:unlock()
    end
    function circuit:send_cell(cmd, data)
      assert(cmd ~= "versions")
      local cmd_id = assert(tor_cmds[cmd]).id
      if cmd_id >= 128 then
        data = struct.pack(">H", data:len()) .. data
      else
        data = data .. string.rep(string.char(0), PAYLOAD_LEN - data:len())
      end
      circuit:send_raw_cell(cmd_id, data)
    end
    function circuit:erase()
      circuits[id] = nil
    end
    return circuit
  end

  local function ensure_buf(len)
    while recv_buf:len() < len do
      recv_buf = recv_buf .. assert(conn:receive())
    end
  end

  local function read_version_cell(cmd, data)
    assert(cmd == "versions")
    while data:len() >= 2 do
      local vnum = struct.unpack(">H", data)
      if vnum == 3 then
        return true
      end
      data = data:sub(3)
    end
    error("Protocol 3 Missing")
  end

  local function read_certs_cell(cmd, data)
    assert(cmd == "certs")
    local N = struct.unpack(">B", data)
    local pos = 2
    for i = 1, N do
      local type, len = struct.unpack(">BH", data:sub(pos))
      local cert = data:sub(pos + 3, pos + 3 + len - 1)
      pos = pos + 3 + len
      -- print("CERT", type, cert:len())
      -- assert(not certs[type])
      -- certs[type] = cert
    end
  end

  local function read_challenge_cell(cmd, data)
    assert(cmd == "auth_challenge")
    local challenge = data:sub(1, 32)
    local method_count = struct.unpack(">H", data:sub(33))
    for i = 1, method_count do
      local method = struct.unpack(">H", data:sub(35 + (i - 1) * 2))
    end
  end
  local function read_addr(data)
    local type, len = struct.unpack(">BB", data)
    local addr = data:sub(3, 3 + len - 1)
    return data:sub(3 + len)
  end
  local function read_netinfo_cell(cmd, data)
    assert(cmd == "netinfo")
    local time = struct.unpack(">I", data)
    data = read_addr(data:sub(5))
    local my_addr_cnt = struct.unpack(">B", data)
    data = data:sub(2)
    for i = 1, my_addr_cnt do
      data = read_addr(data)
    end
  end

  scheduler.addthread(function()
    scheduler.sleep(0.001)
    while next(circuits) do
      ensure_buf(3)
      local CircID, cmd = struct.unpack(">" .. circ_id_len .. "B", recv_buf)
      local len = PAYLOAD_LEN
      local start = 4
      if cmd == 7 or cmd >= 128 then
        ensure_buf(5)
        len = struct.unpack(">H", recv_buf:sub(start))
        start = 6
      end
      ensure_buf(start + len - 1)
      local data = recv_buf:sub(start, start + len - 1)
      recv_buf = recv_buf:sub(start + len)
      -- print("Receive Cell", tor_cmds[cmd].name)
      if circuits[CircID] then
        circuits[CircID](cmd, data)
      else
        print("Package for unregistered circuit", CircID, cmd)
      end
    end
  end)

  local control = register_circuit(0)

  control:send_raw_cell(7, struct.pack(">HH", 2, 3))

  assert(read_version_cell(util.call_timeout_cb_noreturn(control.read_cell, 5, function()
    error("First Handshake timeout")
  end, control)))
  read_certs_cell(util.call_timeout_cb_noreturn(control.read_cell, 5, function()
    error("First Handshake timeout")
  end, control))
  read_challenge_cell(util.call_timeout_cb_noreturn(control.read_cell, 5, function()
    error("First Handshake timeout")
  end, control))
  read_netinfo_cell(util.call_timeout_cb_noreturn(control.read_cell, 5, function()
    error("First Handshake timeout")
  end, control))

  control:send_cell("netinfo", struct.pack(">I BB BBBB B", os.time(), 4, 4, 0, 0, 0, 0, 0))

  local test_circuit = create_path(register_circuit(1), require"blue.tests.tor_node_infos"["moria1"])

  test_circuit:extend(require"blue.tests.tor_node_infos"["gabelmoo"])
  test_circuit:extend(require"blue.tests.tor_node_infos"["dannenberg"])
  test_circuit:extend(require"blue.tests.tor_node_infos"["BexleyRecipes"])
  -- test_circuit:extend(require"blue.tests.tor_node_infos"["ExitNinja"])
  local provider = test_circuit:provider()
  local conn = matrix.connect("", "", "", provider)
  function conn.on_invite(room)
    print("JOINING", room.name)
    room:join()
  end
  function conn.on_room_joined(room)
    local first = true
    function room.on_sync_finished()
      if first then
        first = false
        if not room.name then
          for i = 1, 5 do
            print("SI", i)
            -- room:send_text_message("MSG "..i)
          end
        end
      end
    end
    function room.on_text_message(message, sender)
      print("MESSAGE", message, sender.name, sender.self)
      decode(message)
      if not sender.self then
        print("SEND", room:send_text_message("Answer: " .. message), true)
      end
    end
  end
  conn:start()
  print("DONE")

  --[[




  local rfc
  local function read_created2_cell(cmd, CircID, data)
    assert(cmd == 11)
    local hlen = struct.unpack(">H", data)
    local hdata = data:sub(3, 3 + hlen - 1)
    rfc(hdata)
  end
  local function read_destroy_cell(cmd, CircID, data)
    assert(cmd == 4)
    print(
        ({[0] = "NONE", "PROTOCOL", "INTERNAL", "REQUESTED", "HIBERNATING", "RESOURCELIMIT", "CONNECTFAILED", "OR_IDENTITY", "OR_CONN_CLOSED", "FINISHED", "TIMEOUT", "DESTROYED", "NOSUCHSERVICE"})[string.byte(
            data)])
    error("Destroy")
  end


  local key_forward

  local function send_create_cell()
    local ud
    ud, rfc = create_ntor()
    local pkg = struct.pack(">HB HH", 1, 10, 2, ud:len()) .. ud
    pkg = pkg .. string.rep(string.char(0), (PAYLOAD_LEN + 3) - pkg:len())
    -- print(pkg:gsub(".",function(a)return string.format("%02X ",string.byte(a))end))
    assert(conn:send(pkg))
  end

  local pkg = struct.pack(">HB I BB BBBB B", 0, 8, os.time(), 4, 4, 0, 0, 0, 0, 0)
  pkg = pkg .. string.rep(string.char(0), (PAYLOAD_LEN + 3) - pkg:len())
  -- print(pkg:gsub(".",function(a)return string.format("%02X ",string.byte(a))end))
  assert(conn:send(pkg))

  local function send_relay_cell()
    local ud = struct.pack(">sI", "78.42.208.205:80", 0x7)
    ud = ""
    -- local pkg=struct.pack(">HB BHHIH",0,3,13,0,1,0,ud:len())..ud
    local stream = aes.new(key_forward)
    local encd = stream.encrypt(struct.pack(">BHHIH", 13, 0, 1, 0, ud:len()) .. ud .. string.rep(string.char(0), PAYLOAD_LEN - 11 - ud:len()))
    encd = encd .. stream.close()
    local pkg = struct.pack(">HB", 1, 3) .. encd
    print("PACKAGE LEMNGTH", pkg:len(), (PAYLOAD_LEN + 3))
    pkg = pkg .. string.rep(string.char(0), (PAYLOAD_LEN + 3) - pkg:len())
    print(pkg:gsub(".", function(a)
      return string.format("%02X ", string.byte(a))
    end))
    assert(conn:send(pkg))
  end

  send_create_cell()
  read_created2_cell(read_cell())
  send_relay_cell()
  -- send_create_fast_cell()

  read_destroy_cell(read_cell())

  print("RECV", read_cell())
  print("RECV", read_cell())
  print("RECV", read_cell())]]
end
return tor
